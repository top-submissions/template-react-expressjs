import { vi, describe, it, expect, beforeEach } from 'vitest';
import * as authValidator from './auth.js';
import pool from '../../db/pool.js';

// Mock the database pool to prevent real network calls during validation tests
vi.mock('../../db/pool.js', () => ({
  default: {
    query: vi.fn(),
  },
}));

/**
 * Utility to execute express-validator chains for unit testing.
 * @param {Array} validations - The array of validation chains to run.
 * @param {Object} data - The mock request body data.
 * @returns {Promise<Array>} List of error objects generated by the chains.
 */
const runValidation = async (validations, data) => {
  // Create mock request and response objects
  const req = { body: data };

  // Execute each validation chain in the array
  await Promise.all(validations.map((validation) => validation.run(req)));

  // Extract and return validation result errors
  const { validationResult } = await import('express-validator');
  return validationResult(req).array();
};

describe('authValidator module', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('validateSignup', () => {
    it('should fail if username contains invalid characters', async () => {
      // Define payload with illegal characters
      const data = {
        username: 'user@123',
        password: 'Password1',
        confirmPassword: 'Password1',
      };

      const errors = await runValidation(authValidator.validateSignup, data);

      // Verify specific error message for formatting
      expect(
        errors.some((e) => e.msg.includes('letters, numbers, and underscores')),
      ).toBe(true);
    });

    it('should fail if username is already taken in the database', async () => {
      const data = {
        username: 'existingUser',
        password: 'Password1',
        confirmPassword: 'Password1',
      };

      // Setup: Mock database to find a conflict
      pool.query.mockResolvedValue({ rows: [{ id: 1 }] });

      const errors = await runValidation(authValidator.validateSignup, data);

      // Verify DB uniqueness logic triggered error
      expect(errors.some((e) => e.msg === 'Username already taken.')).toBe(
        true,
      );
    });

    it('should fail if passwords do not match', async () => {
      const data = {
        username: 'validUser',
        password: 'Password1',
        confirmPassword: 'Mismatch1',
      };

      // Setup: Mock database as empty for this user
      pool.query.mockResolvedValue({ rows: [] });

      const errors = await runValidation(authValidator.validateSignup, data);

      // Verify cross-field validation logic
      expect(
        errors.some((e) => e.msg.includes('confirmation does not match')),
      ).toBe(true);
    });
  });

  describe('validateLogin', () => {
    it('should fail if required fields are missing', async () => {
      // Setup: empty payload to trigger .notEmpty()
      const data = { username: '', password: '' };

      const errors = await runValidation(authValidator.validateLogin, data);

      // Verify: both fields triggered errors
      expect(errors.length).toBe(2);

      // Use .some() or .toContain() logic so the array order doesn't break the test
      const messages = errors.map((e) => e.msg);
      expect(messages).toContain('Username is required.');
      expect(messages).toContain('Password is required.');
    });
  });

  describe('validateSignupWithEmail', () => {
    it('should fail if email format is invalid', async () => {
      const data = {
        username: 'validUser',
        password: 'Password1',
        confirmPassword: 'Password1',
        email: 'not-an-email',
      };

      pool.query.mockResolvedValue({ rows: [] });

      const errors = await runValidation(
        authValidator.validateSignupWithEmail,
        data,
      );

      // Verify email-specific validation chain
      expect(
        errors.some((e) => e.msg.includes('must be a valid email address')),
      ).toBe(true);
    });
  });
});
